/*
the following is some code that could be used to debug
and experiment with the above type maps. from a python shell
run the following:

    from teca import *
    import numpy as np
    import sys
    test_typemaps()

the test_typemaps() call will pass NumPy scalars through a test API generated by
SWIG. As the code runs you will see console output detailing the decisions
made by the SWIG generated code.
*/
#ifdef TECA_DEBUG_TYPES
%inline
%{

void test_typemap(double val)
{
    std::cerr << "received double " << val << std::endl;
}

void test_typemap(float val)
{
    std::cerr << "received float " << val << std::endl;
}

void test_typemap(char val)
{
    std::cerr << "received char " << val << std::endl;
}

void test_typemap(short val)
{
    std::cerr << "received short " << val << std::endl;
}

void test_typemap(int val)
{
    std::cerr << "received integer " << val << std::endl;
}

void test_typemap(long val)
{
    std::cerr << "received long  " << val << std::endl;
}

void test_typemap(long long val)
{
    std::cerr << "received long long " << val << std::endl;
}

void test_typemap_i()
{
    std::cerr << "received void " << std::endl;
}

void test_typemap_i(int val)
{
    std::cerr << "received int " << val << std::endl;
}

void test_typemap_c(char val)
{
    std::cerr << "received char " << val << std::endl;
}

void test_typemap_l(long val)
{
    std::cerr << "received long " << val << std::endl;
}

void test_typemap_f()
{
    std::cerr << "received void " << std::endl;
}

void test_typemap_f(float val)
{
    std::cerr << "received float " << val << std::endl;
}

void test_typemap_d()
{
    std::cerr << "received void" << std::endl;
}

void test_typemap_d(double val)
{
    std::cerr << "received doouble " << val << std::endl;
}


void test_conversion(float val)
{
    std::cerr << "received float " << val << std::endl;
}

%}

%pythoncode
%{
def test_typemaps():

    def msg(m):
        sys.stderr.write('\ntesting %s ...\n'%(m))
        sys.stderr.flush()

    msg('int')
    test_typemap(int(1))

    msg('float')
    test_typemap(float(1.2))

    msg('np.float64')
    test_typemap(np.float64(3.2))

    msg('np.float32')
    test_typemap(np.float32(4.4))

    msg('np.int8')
    test_typemap(np.int8(8))

    msg('np.int16')
    test_typemap(np.int16(16))

    msg('np.int32')
    test_typemap(np.int32(32))

    msg('np.int64')
    test_typemap(np.int64(64))

    msg('simple overload int')
    test_typemap_i()
    test_typemap_i(int(1))

    test_typemap_c(int(2))
    test_typemap_l(int(3))

    msg('simple overload float')
    test_typemap_f()
    test_typemap_f(float(4))


    msg('simple overload double')
    test_typemap_d()
    test_typemap_d(float(5))

    msg('test automatic conversion from float')
    test_conversion(float(3.14))
    msg('test automatic conversion from int')
    test_conversion(int(3))
    msg('test automatic conversion from np.float32')
    test_conversion(np.float32(3.14))
    msg('test automatic conversion from np.float64')
    test_conversion(np.float64(3.14))
    msg('test automatic conversion from np.int8')
    test_conversion(np.int8(3))
    msg('test automatic conversion from np.int16')
    test_conversion(np.int16(3))
    msg('test automatic conversion from np.int32')
    test_conversion(np.int32(3))
    msg('test automatic conversion from np.int64')
    test_conversion(np.int64(3))
%}
#endif
