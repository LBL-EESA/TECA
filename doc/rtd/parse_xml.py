#!/usr/bin/env python3

"""A script that parses Doxygen's output XML files and generate documentations
accordingly in RTD format.

Hierarchy trees are constructed based on Doxygen's reading of TECA. The script
parses the XML files that are generated by Doxygen. So far we only generate
the class & file hierarchy trees and show in the main API page. Additionally,
extra rtd pages are generated to include all the related classes, that are
organized under the TECA directories, in a table that includes: the TECA
class's name accompanied by its brief description. Each class name is a
hypertext that directs the user to the appropriate Doxygen documentation page
when clicked.

Authors: Abdelrahman Elbashandy, Burlen Loring, and Travis O'Brien
"""

import os
import xml.etree.ElementTree as ET
from collections import defaultdict


class TECA_Tree(object):
    def __init__(
            self, xml_dir: str = '_build/xml', index_file: str = 'index.xml',
            kinds: list = ['class']):
        """Construct TECA class & file hierarchy trees.

        :param xml_dir: Doxygen's xml directory path
        :param index_file: Doxygen's index.xml path
        :param kinds: A list of Doxygen object kinds or types to be targeted
            by the parser. (default is ['class'])
        """
        if not xml_dir:
            raise ValueError("Doxygen's xml directory needs to be specified")
        if not index_file:
            raise ValueError("Doxygen's index file needs to be specified")
        if not kinds:
            raise ValueError("A list of the Doxygen object types needs to be "
                             "specified")

        self.index_file = index_file
        self.xml_dir = xml_dir
        self.kinds = kinds

        xml_tree = ET.parse(os.path.join(xml_dir, index_file))
        self.xml_root = xml_tree.getroot()

        self.nodes = defaultdict(None)
        self.directory_structure = None

        self.meta_info = {
            'alg': {
                'full_name': 'Algorithms',
                'description': 'TECA\'s suite of algorithms that can \
                                be inserted in functional pipelines'
            },
            'core': {
                'full_name': 'Core',
                'description': 'TECA\'s core components'
            },
            'data': {
                'full_name': 'Data',
                'description': 'TECA\'s data structures'
            },
            'io': {
                'full_name': 'I/O',
                'description': 'TECA\'s I/O components to read datasets \
                                efficiently'
            }
        }

        self.get_components()

        self.generate_file_hierarchy()

        self.rescue_every_family()
        self.generate_class_hierarchy()

        self.generate_api_pages(output_dir='api')

    def get_first_dir(self, trunk_dict):
        """Returns the root directory that has the TECA code."""
        for key, _ in trunk_dict.items():
            if key != 'files':
                return key

    def get_compound_refid(self, name, kind='file'):
        """Get the reference id 'refid' for the XML compound that has a
        specific name and kind.
        """
        for teca_element in self.xml_root.findall('compound'):
            if teca_element.get('kind') == kind:
                if name == teca_element.find('name').text:
                    return teca_element.get('refid')

    def get_components(self):
        """Read each XML component that has a kind or type that belongs in the
        list of required kinds.
        """
        for teca_element in self.xml_root.findall('compound'):
            kind = teca_element.get('kind')
            if kind in self.kinds:
                name = teca_element.find('name').text
                # avoid components with '::' in their name attribute
                if '::' not in name:
                    node = self.Node(
                        teca_element.get('refid'),
                        name,
                        self.xml_dir
                        )
                    # Also avoid components that don't have location element
                    # in their main XML file
                    if node.location:
                        self.nodes[teca_element.get('refid')] = node

    def rescue_every_family(self):
        """Connect each tree node to its base (parent) & derived (children)
        nodes.
        
        This information is read from the node's XML file that is generated
        through Doxygen.
        """
        for node_refid, node in self.nodes.items():
            node.find_family(self.nodes)

            self.nodes[node_refid] = node

    def generate_class_hierarchy(self, output_dir='_build/rst'):
        """Generates the class hierarchy tree in raw rst formatted text to be
        compiled by sphinx, and to be included by the main RTD docs.
        """
        def structure_class_hierarchy(
                node, element_type='Class', lastChild=False):
            """A recursive function that traverses the class hierarchy tree
            and generate raw html code creating a collapsible list with the
            proper structure.
            """
            html = ''
            if lastChild:
                html += '<li class="lastChild">'
            else:
                html += '<li>'

            html += element_type + ' <a href="' + node.refid + '.html">'
            html += node.name + '</a>'

            # if node has derived classes, recursively go through the children
            # nodes to build the correct html list structure.
            if node.children:
                html += '<ul>'
                children_len_minus_one = len(node.children) - 1
                for i, child_node in enumerate(node.children):
                    if i == children_len_minus_one:
                        html += structure_class_hierarchy(
                                    child_node, lastChild=True)
                    else:
                        html += structure_class_hierarchy(child_node)
                html += '</ul>'
            html += '</li>'
            return html

        # generating rst embedded html code in a string format
        rst = '\nClass Hierarchy\n---------------\n\n.. raw:: html\n\n   '

        html = '<ul class="treeView" id="class-treeView">'
        html += '<li><ul class="collapsibleList">'

        # find root nodes. i.e. nodes that don't have base (parent) classes.
        root_nodes = []
        for _, node in self.nodes.items():
            if node.parent is None and ('::' not in node.name):
                root_nodes.append(node)

        # find the tree hierarchy for each root node
        for i, root_node in enumerate(root_nodes):
            if i == len(root_nodes) - 1:
                html += structure_class_hierarchy(root_node, lastChild=True)
            else:
                html += structure_class_hierarchy(root_node)

        html += '</ul></li></ul>'

        rst += html + '\n\n.. end raw html for treeView\n'

        if not os.path.exists(output_dir):
            os.makedirs(output_dir)

        # writing the generated raw rst embedded html string to a rst file
        with open(os.path.join(
                    output_dir, 'generated_rtd_class_hierarchy.rst'),
                  'w') as f:
            f.write(rst)

    def generate_file_hierarchy(self, output_dir='_build/rst'):
        """Generates the file hierarchy tree in raw rst formatted text to be
        compiled by sphinx, and to be included by the main RTD docs.
        """
        def structure_file_hierarchy(name, trunk, lastChild=False):
            """A recursive function that traverses the file hierarchy tree
            and generate raw html code creating a collapsible list with the
            proper structure.
            """
            html = ''
            if lastChild:
                html += '<li class="lastChild">'
            else:
                html += '<li>'

            html += name

            trunk_len_minus_one = len(trunk.items()) - 1
            for i, (key, value) in enumerate(trunk.items()):
                html += '<ul>'

                if key == 'files': # this key links to an array of files
                    files_len_minus_one = len(value) - 1
                    for j, file in enumerate(value):
                        if j == files_len_minus_one:
                            html += '<li class="lastChild">'
                        else:
                            html += '<li>'
                        html += '<a href="' + file[2] + '.html">'
                        html += file[0] + '</a>'
                        html += '</li>'
                else: # indicates that the key represents a directory
                    # we recursively go through each directory             
                    if i == trunk_len_minus_one:
                        html += structure_file_hierarchy(
                                    key, trunk[key], lastChild=True)
                    else:
                        html += structure_file_hierarchy(key, trunk[key])
                html += '</ul>'
            html += '</li>'

            return html

        # creating the main trunk to which all filles will be attached
        trunk = defaultdict(dict, (('files', []),))

        def attach(location, trunk, refid):
            """Attach files to the directory tree (trunk) according to their
            order in the file structure. This is done through using
            'defaultdict' data structure in python.
            """
            parts = location.split('/', 1)
            if len(parts) == 1:  # is a file
                trunk['files'].append((
                        parts[0],
                        refid,
                        self.get_compound_refid(parts[0]) + '_source')
                    )
            else:
                directory, others = parts
                if directory not in trunk:
                    trunk[directory] = defaultdict(dict, (('files', []),))
                attach(others, trunk[directory], refid)

        # generating rst embedded html code in a string format
        rst = '\nFile Hierarchy\n---------------\n\n.. raw:: html\n\n   '

        html = '<ul class="treeView" id="file-treeView">'
        html += '<li><ul class="collapsibleList">'

        for _, node in self.nodes.items():
            # attaching files to the main trunk
            attach(node.location, trunk, node.refid)

        # in the case where TECA was cloned to a different directory name than
        # 'TECA', fix the name to be TECA for consistency
        trunk['TECA'] = trunk.pop(self.get_first_dir(trunk))
        self.directory_structure = trunk

        first_dir = 'TECA'
        # generate the html inner list structure '<li>' for all files
        html += structure_file_hierarchy(
                    first_dir, trunk[first_dir], lastChild=True)

        html += '</ul></li></ul>'

        rst += html + '\n\n.. end raw html for treeView\n'

        if not os.path.exists(output_dir):
            os.makedirs(output_dir)

        # writing the generated raw rst embedded html string to a rst file
        with open(os.path.join(
                    output_dir, 'generated_rtd_file_hierarchy.rst'),
                  'w') as f:
            f.write(rst)

    def generate_api_pages(self, output_dir='_build/rst'):
        """Generates the API pages for each TECA directory such as: A:w
        lg, I/O,
        etc.

        Each API page contains a table with each TECA class that belongs in
        its TECA categorical directory. The table has two columns:

        1) TECA class name
        2) Brief description for the class

        The class name is a hypertext that links to the class's doxygen
        documentation page.
        """
        first_dir = 'TECA'
        # get the directory tree that was created in generate_file_hierarchy() 
        trunk = self.directory_structure[first_dir]

        if not os.path.exists(output_dir):
            os.makedirs(output_dir)

        generated_files = []

        for key, value in trunk.items():
            if key == 'files':
                # we are only looking for directories
                continue

            page_name = self.meta_info[key]['full_name']

            # generating rst embedded code in a string format
            rst = ''
            rst += '\n.. _' + page_name + ':\n'
            rst += '\n' + page_name + '\n'
            rst += '-' * len(page_name) + '\n\n'
            rst += self.meta_info[key]['description'] + '. '
            rst += '(For more details, click on the class name) \n\n'

            # create the API table using the 'csv-table' directive in rst
            rst += '.. csv-table:: TECA Classes\n'
            rst += '   :header: "Class", "Description"\n'
            rst += '   :widths: 5, 30\n\n'

            # go through all the nodes that belong to this API and add them to
            # the generated table. Each row has the node's name and its brief
            # description
            for _, refid, _ in value['files']:
                node = self.nodes[refid]

                rst += '   ' + node.name + '_ , '

                if (node.brief_description and
                        not node.brief_description.isspace()):
                    rst += node.brief_description.strip()

                rst += '\n'

            rst += '\n'
            # adding the correct hyperlink that corresponds to each node's
            # doxygen generated html file
            for _, refid, _ in value['files']:
                node = self.nodes[refid]

                rst += '.. _' + node.name + ': ' + node.refid + '.html\n'

            filename = 'generated_rtd_%s.rst' % key
            with open(os.path.join(output_dir, filename), 'w') as f:
                f.write(rst)

            generated_files.append(
                (filename, self.meta_info[key]['full_name']))

        rst = '\n\n.. toctree::\n   :maxdepth: 1\n   :caption: Contents:\n\n'

        for file, full_name in generated_files:
            rst += '   ' + full_name + '<' + file.replace('.rst', '') + '>\n'

        # writing the generated raw rst embedded html string to a rst file
        with open(os.path.join(
                    output_dir, 'generated_rtd_pages.rst'),
                  'w') as f:
            f.write(rst)

    class Node:
        def __init__(self, refid, name, xml_dir):
            """A class object for each XML compound, or TECA class in our
            context.

            Each object is referred to as a node. Each node encapsulates all
            the attributes (metadata) that correspond to it like: the class's
            base and derived classes, the class's brief and detailed
            descriptions, etc.
            """
            self.refid = refid
            self.name = name

            self.xml_dir = xml_dir

            self.location = None

            self.brief_description = None

            self.parent = None
            self.children = []
            self.found_family = False

            self.node_xml_root = None

            self._construct_xml_root()
            self.find_location()
            self.find_brief_description()

        def _construct_xml_root(self):
            """Constructing an XML tree out of the node's reference id.

            Each doxygen compound has an XML file that has all the relevant
            details. This function constructs the XML tree from the node's
            corresponding file. Doxygen's filename structure is:
            
            node_file = self.refid + '.xml'
            """
            node_xml_tree = ET.parse(
                os.path.join(self.xml_dir, self.refid + '.xml'))

            node_xml_root = node_xml_tree.getroot()
            self.node_xml_root = node_xml_root.find('compounddef')

        def find_location(self, avoids=['.cxx']):
            """Find the XML file location for this node."""
            if self.node_xml_root is None:
                raise ValueError("The Node's xml tree root has to be set!")

            location = self.node_xml_root.find('location')
            if location is not None:
                location = location.get('file')
                # the 'avoids' array holds string templates to ignore.
                # e.g. we don't want include .cxx files
                for txt in avoids:
                    if txt in location:
                        return
                self.location = location

        def find_brief_description(self):
            """Find the brief description for this node."""
            if self.node_xml_root is None:
                raise ValueError("The Node's xml tree root has to be set!")

            briefdescription = self.node_xml_root.find('briefdescription')

            brief_description = ""
            # get all the element's inner text (including text from
            # subelements)
            for text in briefdescription.itertext():
                brief_description += text

            self.brief_description = brief_description

        def find_family(self, nodes):
            """Find all the nodes that are directly related to this node."""
            if self.found_family:
                return

            if self.node_xml_root is None:
                raise ValueError("The Node's xml tree root has to be set!")

            # reading the base class for this node
            parent = self.node_xml_root.find('basecompoundref')
            if parent is not None and 'refid' in parent.attrib:
                self.parent = nodes[parent.get('refid')]

            # reading the derived classes of this node
            children = []
            for child_element in self.node_xml_root.findall(
                    'derivedcompoundref'):
                if 'refid' in child_element.attrib:
                    child = nodes[child_element.get('refid')]
                    children.append(child)

            self.children = children

            # to indicate that this node has found all its base/derived
            # classes.
            self.found_family = True


def main():
    teca_tree = TECA_Tree()


if __name__ == '__main__':
    main()
